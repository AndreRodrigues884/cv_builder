"""
üì¶ CV Builder - Export to Backend
Exporta datasets do Python para m√≥dulos JavaScript/Node.js

Este script converte os datasets JSON em m√≥dulos ES6 prontos para usar no backend.

"""

import json
from pathlib import Path
from datetime import datetime

class BackendExporter:
    def __init__(self):
        self.datasets_dir = Path("datasets/processed")
        self.backend_dir = Path("../backend/src/data")
        
        # Criar pasta de destino se n√£o existir
        self.backend_dir.mkdir(parents=True, exist_ok=True)
    
    def export_as_js_module(self, data: dict, filename: str) -> Path:
        """Converte JSON Python para m√≥dulo ES6 JavaScript"""
        
        # Nome da vari√°vel (remover extens√£o e substituir caracteres especiais)
        var_name = filename.replace('.json', '').replace('.', '_').replace('-', '_')
        
        # Template do m√≥dulo ES6
        js_content = f"""/**
 * ü§ñ Auto-generated by ML Engine
 * Dataset: {filename}
 * Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 * 
 * ‚ö†Ô∏è DO NOT EDIT MANUALLY - Changes will be overwritten
 * To update, modify the Python datasets and run: python scripts/export_to_backend.py
 */

export const {var_name} = {json.dumps(data, ensure_ascii=False, indent=2)};

export default {var_name};
"""
        
        output_file = self.backend_dir / f"{filename.replace('.json', '')}.js"
        with open(output_file, "w", encoding="utf-8") as f:
            f.write(js_content)
        
        return output_file
    
    def create_index_file(self, exported_files: list) -> Path:
        """Cria arquivo index.js para importar todos os datasets"""
        
        imports = []
        exports = []
        
        for file in exported_files:
            name = file.stem  # Nome do arquivo sem extens√£o
            imports.append(f"import {name} from './{name}.js';")
            exports.append(f"  {name}")
        
        # Template do index.js com helper functions
        index_content = f"""/**
 * ü§ñ CV Builder - ML Datasets Index
 * Centraliza todos os datasets para uso no backend Node.js
 * 
 * Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
 */

{chr(10).join(imports)}

// ========== EXPORTS ==========

export {{
{(',' + chr(10)).join(exports)}
}};

// ========== HELPER FUNCTIONS ==========

/**
 * Buscar skill por nome em qualquer √°rea
 * @param {{string}} skillName - Nome da skill
 * @param {{string}} [area] - √Årea espec√≠fica (opcional)
 * @returns {{Object|null}} - Skill encontrada ou null
 * 
 * @example
 * const reactSkill = findSkill('React', 'technology');
 * console.log(reactSkill.demand_score); // 95
 */
export const findSkill = (skillName, area = null) => {{
  const db = skills_by_area;
  
  if (!db || typeof db !== 'object') {{
    console.warn('skills_by_area dataset not loaded');
    return null;
  }}
  
  const searchInArea = (areaData) => {{
    for (const category in areaData) {{
      if (Array.isArray(areaData[category])) {{
        const found = areaData[category].find(s => 
          s.name && s.name.toLowerCase() === skillName.toLowerCase()
        );
        if (found) return {{ ...found, category }};
      }}
    }}
    return null;
  }};
  
  // Buscar em √°rea espec√≠fica
  if (area && db[area]) {{
    const result = searchInArea(db[area]);
    if (result) return {{ ...result, area }};
  }}
  
  // Buscar em todas as √°reas
  for (const areaKey in db) {{
    if (areaKey === 'metadata') continue;
    if (typeof db[areaKey] !== 'object') continue;
    
    const result = searchInArea(db[areaKey]);
    if (result) return {{ ...result, area: areaKey }};
  }}
  
  return null;
}};

/**
 * Obter keywords ATS por √°rea
 * @param {{string}} area - √Årea profissional (technology, marketing, etc)
 * @returns {{Object}} - Keywords ATS organizadas
 * 
 * @example
 * const techKeywords = getATSKeywords('technology');
 * console.log(techKeywords.must_have); // ['desenvolveu', 'implementou', ...]
 */
export const getATSKeywords = (area) => {{
  if (!ats_keywords || typeof ats_keywords !== 'object') {{
    console.warn('ats_keywords dataset not loaded');
    return {{}};
  }}
  return ats_keywords[area] || {{}};
}};

/**
 * Encontrar exemplos de melhoria por sec√ß√£o
 * @param {{string}} section - Sec√ß√£o do CV (experience, summary, education, skills)
 * @returns {{Array}} - Exemplos de melhoria
 * 
 * @example
 * const examples = findImprovementExamples('experience');
 * console.log(examples[0].improved);
 */
export const findImprovementExamples = (section) => {{
  if (!text_improvement || !text_improvement.by_section) {{
    console.warn('text_improvement dataset not loaded');
    return [];
  }}
  return text_improvement.by_section[section] || [];
}};

/**
 * Obter top skills por √°rea e prioridade
 * @param {{string}} area - √Årea profissional
 * @param {{string}} [priority='high'] - Prioridade (high, medium, low)
 * @param {{number}} [limit=10] - N√∫mero m√°ximo de skills
 * @returns {{Array}} - Lista de skills ordenadas por demand_score
 * 
 * @example
 * const topSkills = getTopSkills('technology', 'high', 5);
 * topSkills.forEach(skill => console.log(skill.name, skill.demand_score));
 */
export const getTopSkills = (area, priority = 'high', limit = 10) => {{
  const db = skills_by_area;
  if (!db || !db[area]) {{
    console.warn(`Area '${{area}}' not found in skills database`);
    return [];
  }}
  
  const skills = [];
  
  // Coletar skills de todas as subcategorias
  for (const category in db[area]) {{
    if (Array.isArray(db[area][category])) {{
      const filtered = db[area][category].filter(s => 
        s.priority === priority
      );
      skills.push(...filtered.map(s => ({{ ...s, category }})));
    }}
  }}
  
  // Ordenar por demand_score (descendente)
  return skills
    .sort((a, b) => (b.demand_score || 0) - (a.demand_score || 0))
    .slice(0, limit);
}};

/**
 * Obter skills recomendadas para um cargo espec√≠fico
 * @param {{string}} jobTitle - T√≠tulo do cargo
 * @param {{Array}} currentSkills - Skills que o user j√° possui
 * @returns {{Array}} - Skills recomendadas
 * 
 * @example
 * const recommendations = getSkillsForJob('Frontend Developer', ['HTML', 'CSS']);
 */
export const getSkillsForJob = (jobTitle, currentSkills = []) => {{
  const db = skills_by_area;
  const normalizedCurrent = currentSkills.map(s => s.toLowerCase());
  
  // Mapeamento de cargo para √°rea
  const jobToArea = {{
    'frontend developer': ['technology.frontend'],
    'backend developer': ['technology.backend'],
    'full stack developer': ['technology.frontend', 'technology.backend'],
    'devops engineer': ['technology.devops'],
    'data analyst': ['technology.data_science'],
    'digital marketer': ['marketing.digital_marketing'],
  }};
  
  const jobKey = jobTitle.toLowerCase();
  const areas = jobToArea[jobKey] || [];
  
  const recommendations = [];
  
  areas.forEach(areaPath => {{
    const [area, category] = areaPath.split('.');
    if (db[area] && db[area][category]) {{
      const skills = db[area][category];
      skills.forEach(skill => {{
        // Sugerir apenas skills que o user ainda n√£o tem
        if (!normalizedCurrent.includes(skill.name.toLowerCase())) {{
          recommendations.push({{
            ...skill,
            area,
            category,
            reason: `Essencial para ${{jobTitle}}`
          }});
        }}
      }});
    }}
  }});
  
  // Ordenar por prioridade e demand_score
  const priorityWeight = {{ high: 3, medium: 2, low: 1 }};
  return recommendations
    .sort((a, b) => {{
      const priorityDiff = priorityWeight[b.priority] - priorityWeight[a.priority];
      if (priorityDiff !== 0) return priorityDiff;
      return (b.demand_score || 0) - (a.demand_score || 0);
    }})
    .slice(0, 6);
}};

/**
 * Validar se texto melhorou baseado em keywords e padr√µes
 * @param {{string}} original - Texto original
 * @param {{string}} improved - Texto melhorado
 * @returns {{Object}} - An√°lise da melhoria
 * 
 * @example
 * const analysis = validateImprovement(
 *   'Trabalhei na empresa',
 *   'Desenvolvi aplica√ß√µes React aumentando efici√™ncia em 30%'
 * );
 * console.log(analysis.score); // 100
 */
export const validateImprovement = (original, improved) => {{
  const analysis = {{
    hasActionVerb: false,
    hasQuantification: false,
    hasSpecificity: false,
    lengthAppropriate: false,
    hasKeywords: false,
    score: 0,
    suggestions: []
  }};
  
  // 1. Verificar verbos de a√ß√£o fortes
  const actionVerbs = [
    'desenvolvi', 'implementei', 'geri', 'liderei', 'otimizei', 
    'aumentei', 'reduzi', 'arquitetei', 'coordenei', 'executei',
    'criei', 'constru√≠', 'lancei', 'melhorei', 'automatizei'
  ];
  analysis.hasActionVerb = actionVerbs.some(verb => 
    improved.toLowerCase().includes(verb)
  );
  if (!analysis.hasActionVerb) {{
    analysis.suggestions.push('Adicione um verbo de a√ß√£o forte no in√≠cio');
  }}
  
  // 2. Verificar quantifica√ß√£o (n√∫meros, percentagens, valores)
  const quantificationPattern = /\\d+[%‚Ç¨$KM]|\\d+\\+|\\d+\\/\\d+|\\d+ (anos|meses|pessoas|projetos|utilizadores)/i;
  analysis.hasQuantification = quantificationPattern.test(improved);
  if (!analysis.hasQuantification) {{
    analysis.suggestions.push('Adicione m√©tricas quantific√°veis (%, n√∫meros, valores)');
  }}
  
  // 3. Verificar especificidade (texto melhorado mais detalhado)
  analysis.hasSpecificity = improved.length > original.length * 1.5;
  if (!analysis.hasSpecificity) {{
    analysis.suggestions.push('Adicione mais detalhes espec√≠ficos sobre tecnologias ou resultados');
  }}
  
  // 4. Verificar comprimento apropriado
  const wordCount = improved.split(/\\s+/).length;
  analysis.lengthAppropriate = wordCount >= 10 && wordCount <= 50;
  if (!analysis.lengthAppropriate) {{
    if (wordCount < 10) {{
      analysis.suggestions.push('Texto muito curto - adicione mais detalhes');
    }} else {{
      analysis.suggestions.push('Texto muito longo - seja mais conciso');
    }}
  }}
  
  // 5. Verificar presen√ßa de keywords t√©cnicas/profissionais
  const hasUpperCase = /[A-Z]{{2,}}/.test(improved); // Siglas/tecnologias
  const hasTechnicalTerms = /(React|Node|Python|JavaScript|AWS|Docker|SQL|API|Git)/i.test(improved);
  analysis.hasKeywords = hasUpperCase || hasTechnicalTerms;
  if (!analysis.hasKeywords) {{
    analysis.suggestions.push('Mencione tecnologias ou ferramentas espec√≠ficas');
  }}
  
  // Calcular score final (0-100)
  const criteria = [
    analysis.hasActionVerb,
    analysis.hasQuantification,
    analysis.hasSpecificity,
    analysis.lengthAppropriate,
    analysis.hasKeywords
  ];
  analysis.score = criteria.filter(Boolean).length * 20;
  
  // Classifica√ß√£o
  if (analysis.score >= 80) {{
    analysis.quality = 'excellent';
  }} else if (analysis.score >= 60) {{
    analysis.quality = 'good';
  }} else if (analysis.score >= 40) {{
    analysis.quality = 'fair';
  }} else {{
    analysis.quality = 'poor';
  }}
  
  return analysis;
}};

/**
 * Obter template de sum√°rio por role e seniority
 * @param {{string}} role - Role profissional
 * @param {{string}} seniority - N√≠vel (junior, mid-level, senior)
 * @param {{string}} tone - Tom (professional, casual, confident)
 * @returns {{Object|null}} - Template encontrado
 */
export const getSummaryTemplate = (role, seniority = 'mid-level', tone = 'professional') => {{
  if (!summary_templates || !summary_templates.templates_by_role) {{
    console.warn('summary_templates dataset not loaded');
    return null;
  }}
  
  const roleTemplates = summary_templates.templates_by_role[role];
  if (!roleTemplates) return null;
  
  const seniorityTemplates = roleTemplates[seniority];
  if (!seniorityTemplates) return null;
  
  return seniorityTemplates[tone] || seniorityTemplates.professional || null;
}};

/**
 * Calcular ATS score de um texto
 * @param {{string}} text - Texto do CV
 * @param {{string}} area - √Årea profissional
 * @returns {{Object}} - Score e an√°lise
 */
export const calculateATSScore = (text, area = 'technology') => {{
  const keywords = getATSKeywords(area);
  const lowerText = text.toLowerCase();
  
  let score = 0;
  const foundKeywords = [];
  const missingKeywords = [];
  
  // Verificar must_have keywords (peso 3)
  if (keywords.must_have) {{
    keywords.must_have.forEach(keyword => {{
      if (lowerText.includes(keyword.toLowerCase())) {{
        score += 3;
        foundKeywords.push(keyword);
      }} else {{
        missingKeywords.push(keyword);
      }}
    }});
  }}
  
  // Verificar strong keywords (peso 2)
  if (keywords.strong) {{
    keywords.strong.forEach(keyword => {{
      if (lowerText.includes(keyword.toLowerCase())) {{
        score += 2;
        foundKeywords.push(keyword);
      }}
    }});
  }}
  
  // Normalizar para 0-100
  const maxScore = (keywords.must_have?.length || 0) * 3 + (keywords.strong?.length || 0) * 2;
  const normalizedScore = maxScore > 0 ? Math.min(100, (score / maxScore) * 100) : 0;
  
  return {{
    score: Math.round(normalizedScore),
    foundKeywords,
    missingKeywords: missingKeywords.slice(0, 5),
    recommendation: normalizedScore >= 70 ? 'good' : 'needs_improvement'
  }};
}};
"""
        
        index_file = self.backend_dir / "index.js"
        with open(index_file, "w", encoding="utf-8") as f:
            f.write(index_content)
        
        return index_file
    
    def export_all(self):
        """Exporta todos os datasets para o backend"""
        print("\n" + "="*70)
        print("üì¶ CV Builder - Export to Backend")
        print("="*70)
        print()
        
        # Verificar se pasta de datasets existe
        if not self.datasets_dir.exists():
            print(f"‚ùå Erro: Pasta {self.datasets_dir} n√£o encontrada!")
            print(f"üí° Execute primeiro: python scripts/generate_datasets.py")
            return False
        
        exported_files = []
        total_size = 0
        
        # Listar todos os JSONs processados
        json_files = sorted(self.datasets_dir.glob("*.json"))
        
        if not json_files:
            print(f"‚ùå Nenhum arquivo JSON encontrado em {self.datasets_dir}")
            print(f"üí° Execute primeiro: python scripts/generate_datasets.py")
            return False
        
        print(f"üìÇ Encontrados {len(json_files)} arquivos JSON")
        print(f"üìÅ Destino: {self.backend_dir.absolute()}")
        print()
        
        # Processar cada arquivo JSON
        for json_file in json_files:
            try:
                print(f"   Processando {json_file.name}...", end=" ", flush=True)
                
                # Carregar JSON
                with open(json_file, "r", encoding="utf-8") as f:
                    data = json.load(f)
                
                # Exportar como m√≥dulo JS
                output = self.export_as_js_module(data, json_file.name)
                exported_files.append(output)
                
                # Calcular tamanho
                size_kb = output.stat().st_size / 1024
                total_size += size_kb
                
                print(f"‚úÖ ({size_kb:.1f} KB)")
                
            except json.JSONDecodeError as e:
                print(f"‚ùå Erro ao parsear JSON: {e}")
            except Exception as e:
                print(f"‚ùå Erro: {e}")
        
        # Criar index.js
        print()
        print(f"üìù Criando index.js com helper functions...", end=" ", flush=True)
        index_file = self.create_index_file(exported_files)
        index_size_kb = index_file.stat().st_size / 1024
        total_size += index_size_kb
        print(f"‚úÖ ({index_size_kb:.1f} KB)")
        
        # Resumo final
        print()
        print("="*70)
        print("‚ú® Exporta√ß√£o conclu√≠da com sucesso!")
        print("="*70)
        print()
        print(f"üìä Estat√≠sticas:")
        print(f"   ‚Ä¢ Arquivos criados: {len(exported_files) + 1}")
        print(f"   ‚Ä¢ Tamanho total: {total_size:.1f} KB")
        print(f"   ‚Ä¢ Localiza√ß√£o: {self.backend_dir.absolute()}")
        print()
        print(f"üìÑ Arquivos gerados:")
        for file in exported_files:
            print(f"   ‚úÖ {file.name}")
        print(f"   ‚úÖ index.js (com 9 helper functions)")
        print()
        print(f"üí° Uso no backend Node.js:")
        print(f"   import {{ skills_by_area, text_improvement }} from './src/data/index.js';")
        print(f"   import {{ findSkill, getATSKeywords }} from './src/data/index.js';")
        print()
        print(f"üéØ Pr√≥ximo passo:")
        print(f"   cd ../backend && npm run dev")
        
        return True

def main():
    """Fun√ß√£o principal"""
    exporter = BackendExporter()
    success = exporter.export_all()
    
    if not success:
        print("\n‚ö†Ô∏è  Exporta√ß√£o falhou. Verifique os erros acima.")
        exit(1)
    
    exit(0)

if __name__ == "__main__":
    main()